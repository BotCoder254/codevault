// @ts-nocheck
import { writable, derived } from 'svelte/store';
import { user } from './auth.js';
import { db } from '../firebase.js';
import { doc, getDoc, updateDoc, arrayUnion, arrayRemove } from 'firebase/firestore';

export const linkedComponents = writable([]);
export const availableComponents = writable([]);
export const loadingComponents = writable(false);

// Add a component link to a snippet
export const addComponentLink = async (snippetId, componentId) => {
  try {
    const currentUser = await new Promise((resolve) => {
      let userUnsubscribe;
      userUnsubscribe = user.subscribe((u) => {
        if (userUnsubscribe) userUnsubscribe();
        resolve(u);
      });
    });
    
    if (!currentUser) throw new Error('User not authenticated');
    
    const snippetRef = doc(db, 'snippets', snippetId);
    
    await updateDoc(snippetRef, {
      linkedComponents: arrayUnion(componentId),
      updatedAt: new Date()
    });
    
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
};

// Remove a component link from a snippet
export const removeComponentLink = async (snippetId, componentId) => {
  try {
    const snippetRef = doc(db, 'snippets', snippetId);
    
    await updateDoc(snippetRef, {
      linkedComponents: arrayRemove(componentId),
      updatedAt: new Date()
    });
    
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
};

// Load linked components for a snippet
export const loadLinkedComponents = async (componentIds) => {
  try {
    loadingComponents.set(true);
    
    if (!componentIds || componentIds.length === 0) {
      linkedComponents.set([]);
      loadingComponents.set(false);
      return { success: true, components: [] };
    }
    
    const components = [];
    
    for (const componentId of componentIds) {
      const componentDoc = await getDoc(doc(db, 'snippets', componentId));
      if (componentDoc.exists()) {
        components.push({
          id: componentDoc.id,
          ...componentDoc.data()
        });
      }
    }
    
    linkedComponents.set(components);
    loadingComponents.set(false);
    
    return { success: true, components };
  } catch (error) {
    loadingComponents.set(false);
    return { success: false, error: error.message };
  }
};

// Generate merged code with all linked components
export const generateMergedCode = (mainSnippet, components) => {
  let mergedCode = '';
  
  // Add header comment
  mergedCode += `// Generated by CodeVault - Merged Components\n`;
  mergedCode += `// Main: ${mainSnippet.title}\n`;
  mergedCode += `// Generated: ${new Date().toISOString()}\n\n`;
  
  // Add linked components first
  components.forEach((component, index) => {
    mergedCode += `// Component ${index + 1}: ${component.title}\n`;
    if (component.description) {
      mergedCode += `// ${component.description}\n`;
    }
    mergedCode += `${component.code}\n\n`;
  });
  
  // Add main snippet
  mergedCode += `// Main Snippet: ${mainSnippet.title}\n`;
  if (mainSnippet.description) {
    mergedCode += `// ${mainSnippet.description}\n`;
  }
  mergedCode += `${mainSnippet.code}\n`;
  
  return mergedCode;
};

// Search for available components to link
export const searchComponents = derived(
  [availableComponents],
  ([$availableComponents]) => (query) => {
    if (!query) return [];
    
    return $availableComponents.filter(component =>
      component.title.toLowerCase().includes(query.toLowerCase()) ||
      component.description.toLowerCase().includes(query.toLowerCase()) ||
      component.tags?.some(tag => tag.toLowerCase().includes(query.toLowerCase()))
    );
  }
);